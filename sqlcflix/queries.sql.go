// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlcflix

import (
	"context"
	"time"
)

const query = `-- name: Query :many
SELECT
    m.id
    , m.title
    , m.added_at
    , m.rating
    , d.directors::TEXT[] AS directors
FROM movies m
LEFT JOIN LATERAL (
    SELECT ARRAY_AGG(p.name ORDER BY p.name) AS directors
    FROM movie_directors md
    JOIN people p ON p.id = md.person_id
    WHERE md.movie_id = m.id
) d ON true
WHERE
    (
        $1::TEXT = ''
        OR to_tsvector('simple', m.title) @@ plainto_tsquery('simple', $1)
        OR EXISTS (
            SELECT 1
            FROM movie_directors md
            JOIN people p ON p.id = md.person_id
            WHERE md.movie_id = m.id
            AND to_tsvector('simple', p.name) @@ plainto_tsquery('simple', $1)
        )
    )
    AND ($2::INT8 = 0 OR EXTRACT(YEAR FROM m.added_at) = $2)
    AND ($3::FLOAT8 = 0 OR m.rating >= $3)
ORDER BY m.rating DESC
LIMIT CASE WHEN $4::INT4 BETWEEN 1 AND 1000 THEN $4 ELSE 1000 END
`

type QueryParams struct {
	Search    string  `db:"search" json:"search"`
	YearAdded int64   `db:"year_added" json:"year_added"`
	MinRating float64 `db:"min_rating" json:"min_rating"`
	Limit     uint64  `db:"limit" json:"limit"`
}

type QueryRow struct {
	ID        int64     `db:"id" json:"id"`
	Title     string    `db:"title" json:"title"`
	AddedAt   time.Time `db:"added_at" json:"added_at"`
	Rating    float64   `db:"rating" json:"rating"`
	Directors []string  `db:"directors" json:"directors"`
}

func (q *Queries) Query(ctx context.Context, arg QueryParams) ([]QueryRow, error) {
	rows, err := q.db.Query(ctx, query,
		arg.Search,
		arg.YearAdded,
		arg.MinRating,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryRow
	for rows.Next() {
		var i QueryRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.AddedAt,
			&i.Rating,
			&i.Directors,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryDirectors = `-- name: QueryDirectors :many
SELECT
    md.movie_id
    , ARRAY_AGG(people.name ORDER BY people.name)::TEXT[] AS directors
FROM movie_directors md
JOIN people ON people.id = md.person_id
WHERE md.movie_id = ANY ($1::INT8[])
GROUP BY md.movie_id
`

type QueryDirectorsRow struct {
	MovieID   int64    `db:"movie_id" json:"movie_id"`
	Directors []string `db:"directors" json:"directors"`
}

func (q *Queries) QueryDirectors(ctx context.Context, dollar_1 []int64) ([]QueryDirectorsRow, error) {
	rows, err := q.db.Query(ctx, queryDirectors, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryDirectorsRow
	for rows.Next() {
		var i QueryDirectorsRow
		if err := rows.Scan(&i.MovieID, &i.Directors); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryPreload = `-- name: QueryPreload :many
SELECT
    id
    , title
    , added_at
    , rating
FROM movies m
WHERE
    (
        $1::TEXT = ''
        OR to_tsvector('simple', title) @@ plainto_tsquery('simple', $1)
        OR EXISTS (
            SELECT 1
            FROM movie_directors md
            JOIN people p ON p.id = md.person_id
            WHERE md.movie_id = id
            AND to_tsvector('simple', p.name) @@ plainto_tsquery('simple', $1)
        )
    )
    AND ($2::INT8 = 0 OR EXTRACT(YEAR FROM added_at) = $2)
    AND ($3::FLOAT8 = 0 OR rating >= $3)
ORDER BY rating DESC
LIMIT CASE WHEN $4::INT4 BETWEEN 1 AND 1000 THEN $4 ELSE 1000 END
`

type QueryPreloadParams struct {
	Search    string  `db:"search" json:"search"`
	YearAdded int64   `db:"year_added" json:"year_added"`
	MinRating float64 `db:"min_rating" json:"min_rating"`
	Limit     uint64  `db:"limit" json:"limit"`
}

func (q *Queries) QueryPreload(ctx context.Context, arg QueryPreloadParams) ([]Movie, error) {
	rows, err := q.db.Query(ctx, queryPreload,
		arg.Search,
		arg.YearAdded,
		arg.MinRating,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Movie
	for rows.Next() {
		var i Movie
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.AddedAt,
			&i.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
